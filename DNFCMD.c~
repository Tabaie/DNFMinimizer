//Defining functions to have DNFs work with each other
#include "ADNF.h"
#include <stdlib.h>

void CancelOutNegation();

void CancelOutAllNegations();

void CPYTO(ADNFClause dst, ADNFClause src)	//Both are considered HEADS
{

	src=src->next;

	while (src)
	{
		//dst to catch up with src
		dst-> next= malloc(sizeof(AAndClause));
		dst-> next-> prev= dst;
		dst= dst->next;
		
		//The actual copying
		dst->set= src->set;

		//src move on
		src= src->next;

	}	

}

<<<<<<< HEAD
AAndClause * GetLastAndClause(ADNFClause dnf)
{
	while (dnf->next)
		dnf=dnf->next;
		
	return dnf;
}
=======
>>>>>>> 04bda1f7717c0aee71438700e25c4486d599e18f

ADNFClause CPY(ADNFClause src)
{
	ADNFClause dst;
	
	dst= malloc(sizeof(AAndClause));
	dst->prev=0;
	
	CPYTO(dst, src);
	
	return dst;
}

//ADNFClause AND( ASet dst, ADNFClause src)	//Returns a linked list of length>=1 "WITHOUT A HEAD"
//{
//	ADNFClause 
//}

void AND( ADNFClause dst, ADNFClause src)
{
<<<<<<< HEAD
	ADNFClause newChainEnd;
=======
	ADNFClause newChainEnd;	//the CURRENT tail of the new chain of and clauses
>>>>>>> 04bda1f7717c0aee71438700e25c4486d599e18f
	ADNFClause oldChainI;	//old chain iterator
//	ADNFClause oldCur;
	ADNFClause srcI; //source iterator
	ADNFClause t;	//temp!
	
<<<<<<< HEAD
	oldChainI=dst->next;
	newChainEnd=dst;
	newChainEnd->next=0;
=======
	oldChainI=dst->next;	//to read the original and clauses from the original linked list
	newChainEnd=dst;	//the head
	newChainEnd->next=0;//empty list for now
>>>>>>> 04bda1f7717c0aee71438700e25c4486d599e18f
	
	while (oldChainI)
	{
		
<<<<<<< HEAD
		for (srcI= src->next; srcI; srcI= srcI->next)
		{
			t=AddClause( newChainEnd, srcI->set | oldChainI->set);	//if it's not added, t=0!
			//Orring two sets means their union.
=======
		for (srcI= src->next; srcI; srcI= srcI->next)	//traverse the other operand to and all the and clauses!
		{
			t=AddClause( newChainEnd, srcI->set | oldChainI->set);	//if it's not added, t=0!
			//Orring two sets means their union, therefore ANDing the and clauses
>>>>>>> 04bda1f7717c0aee71438700e25c4486d599e18f
			
			newChainEnd= (t)? (Last(t)): (newChainEnd);	//if the new clause is not added, it has not deleted anything either
		}
		

		t= oldChainI->next;
		free(oldChainI);
		oldChainI= t;
	}	
	
<<<<<<< HEAD
	dst->next= newFirst;
=======
>>>>>>> 04bda1f7717c0aee71438700e25c4486d599e18f
}

void OR ( ADNFClause dst, ADNFClause src)
{
	for (src=src->next; src; src=src->next)
		AddClause(dst, src->set);
}

<<<<<<< HEAD
void NOT( ADNFClause dst);
=======
void NOT( ADNFClause dst)
{
	ADNFClause oldChainHead;
	ADNFClause newORClause;	//each previously AND clause becomes an OR clause
	oldChainHead->next= dst->next;
	oldChainHead->prev= 0;
	
	dst->next=0;
	InitDNFClause(&newOrClause);
	
	for (oldChainHead= oldChainHead->next; oldChainHead; oldChainHead= oldChainHead->next)
	{
		
	}
}
>>>>>>> 04bda1f7717c0aee71438700e25c4486d599e18f
